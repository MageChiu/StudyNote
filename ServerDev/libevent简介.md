libevent

# libevent核心原理
libevent是一个事件驱动框架，支持三种事件：
- IO事件
- 信号事件
- 时间事件

时间的设置和使用方式是一样的。

## 事件分类
### IO事件
IO事件包含了socket可读、可写、断开、设备可读、可写等和IO相关的事件。libevent主要采用了epoll模型来进行I/O事件的多路复用。epoll的模型：就是在内核管理的设备或者资源上设置等待队列，当资源出现的时候，系统会通知epoll_wait唤醒，进行事件的处理。总的来说，I/O事件的事件驱动依赖操作系统。

### 时间事件

### 信号事件
 简单的解释一下， 即使和i/o无关的信号，也可以作为一个事件进行处理，信号在linux中是进程间通信方式之一， A可以发出一个信号， B可以接受信号，B接受之后可以进行一些操作，问题是， libevent想把信号事件也统一一起处理， 其原理是， 将信号事件这种和I/O无关的事件转换为和I/O有关的，充分利用现有模型统一处理。事实上， 信号事件是采用一个client socket 和一个server socket， client socket只能写， server socket只能读， server sockert将recv到的client socket的文件描述符放到了epoll的事件集合中， 永远不删。 当收到系统信号的时候, 通过client socket进行发送， server socket收到数据，就会触发epoll_wait唤醒，如果发现这是server socket的事件，就会对信号事件进行遍历找到那个等待的。  


## 事件结构
- 时间事件：采用最小堆组织，时间最少的在顶部，插入和删除都是log(N)，主要是方便找到最小的等待时间，方便设置time_out时间
- I/O事件：双向链表
- 信号事件：双向链表


## 事件的处理
1. 激活事件：是libevent 的epoll_wait唤醒后，得到的所有要处理的事件双向链表。
2. 主循环:libevent采用一个主循环来处理所有事件处理和事件等待。





# libevent、libev、libuv对比
三个库都是C语言实现的异步事件库。

异步事件库本质上是提供异步事件通知（Asynchronous Event Notification，AEN）的。异步事件通知机制就是根据发生的事件，调用相应的回调函数进行处理。
- 事件（Event）：事件是异步事件通知机制的核心，比如fd事件、超时事件、信号事件、定时器事件。有时候也称事件为事件处理器（EventHandler），这个名称更形象，因为Handler本身表示了包含处理所需数据（或数据的地址）和处理的方法（回调函数），更像是面向对象思想中的称谓。
- 事件循环（EventLoop）：等待并分发事件。事件循环用于管理事件。
对于应用程序来说，这些只是异步事件库提供的API，封装了异步事件库跟操作系统的交互，异步事件库会选择一种操作系统提供的机制来实现某一种事件，比如利用Unix/Linux平台的epoll机制实现网络IO事件，在同时存在多种机制可以利用时，异步事件库会采用最优机制。

___

- libevent：
- libev：较libevent而言，设计更简练，性能更好，但是对Windows平台支持不够好
- libuv：为了libev能支持Windows，重新封装了一套，Linux下libev实现，Windows下用IOCP实现

| **特性**| **libevent**| **libev**| **libuv** |
|:--:|:--:|:--:|:--:|
| **优先级** | 激活的事件组织在优先级队列中，各类事件默认的优先级是相同的，可以通过设置事件的优先级使其优先被处理 | 也是通过优先级队列来管理激活的时间，也可以设置事件优先级 | 没有优先级概念，按照固定的顺序访问各类事件|
| **事件循环** |  event_base用于管理事件 | 激活的事件组织在优先级队列中，各类事件默认的优先级是相同的，可以通过设置事件的优先级,使其优先被处理  | 同libev |
| 线程安全 | event_base和loop都不是线程安全的，一个event_base或loop实例只能在用户的一个线程内访问（一般是主线程），注册到event_base或者loop的event都是串行访问的，即每个执行过程中，会按照优先级顺序访问已经激活的事件，执行其回调函数。所以在仅使用一个event_base或loop的情况下，回调函数的执行不存在并行关系 | 同libevent | 同libevent| 

